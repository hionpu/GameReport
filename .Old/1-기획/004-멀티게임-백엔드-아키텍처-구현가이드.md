---
title: Multi-Game Backend Architecture Implementation Guide
status: active
created: 2025-06-18
project: Gaming Analytics Platform
updated: 2025-06-18
tech_stack: Go + templ + HTMX
architecture: service-oriented-monolith
---
# 멀티게임 백엔드 아키텍처 구현 가이드

## 🎯 현재 발로란트 서비스를 확장 가능한 구조로 리팩토링

### 1단계: 현재 구조 분석
```
현재 구조 (Phase 1):
valorant-ai-platform/
├── cmd/server/main.go
├── internal/
│   ├── handlers/     # HTTP 핸들러
│   ├── models/       # 데이터 모델
│   └── services/     # 비즈니스 로직
```

### 2단계: 확장 가능한 구조로 변경
```
새로운 구조:
gaming-analytics-platform/
├── cmd/
│   └── server/main.go
├── internal/
│   ├── core/
│   │   ├── domain/          # 공통 도메인 모델
│   │   └── services/        # 공통 비즈니스 로직
│   ├── games/
│   │   ├── valorant/        # 발로란트 전용
│   │   └── common/          # 게임 공통 유틸
│   ├── shared/
│   │   ├── middleware/
│   │   ├── config/
│   │   └── logger/
│   └── infrastructure/
│       ├── http/            # HTTP 핸들러
│       ├── database/        # DB 연결
│       └── ai/              # AI 클라이언트
```

## 🔄 단계별 마이그레이션 계획

### Step 1: 공통 도메인 모델 정의
```go
// internal/core/domain/player.go
type Player struct {
    ID          string    `json:"id"`
    GameType    GameType  `json:"game_type"`
    ExternalID  string    `json:"external_id"`
    DisplayName string    `json:"display_name"`
    CreatedAt   time.Time `json:"created_at"`
}

type GameType string
const (
    GameTypeValorant GameType = "valorant"
    GameTypeLoL      GameType = "lol"
    GameTypeCS2      GameType = "cs2"
)
```

### Step 2: 게임 서비스 인터페이스 정의
```go
// internal/core/ports/game_service.go
type GameService interface {
    GetPlayer(ctx context.Context, identifier string) (*domain.Player, error)
    GetPlayerStats(ctx context.Context, playerID string) (*domain.PlayerStats, error)
    GetMatches(ctx context.Context, playerID string, limit int) ([]domain.Match, error)
}
```

### Step 3: 발로란트 서비스 구현
```go
// internal/games/valorant/service.go
type ValorantService struct {
    client  *RiotClient
    cache   cache.Client
    logger  logger.Logger
}

func (s *ValorantService) GetPlayer(ctx context.Context, identifier string) (*domain.Player, error) {
    // 발로란트 특화 플레이어 조회 로직
    riotPlayer, err := s.client.GetPlayerByRiotID(ctx, identifier)
    if err != nil {
        return nil, err
    }
    
    return s.transformToCommonPlayer(riotPlayer), nil
}
```

### Step 4: HTTP 라우터 구조 변경
```go
// internal/infrastructure/http/router.go
func SetupRouter(gameRegistry *GameRegistry) *chi.Mux {
    r := chi.NewRouter()
    
    // 공통 미들웨어
    r.Use(middleware.RequestID)
    r.Use(middleware.Logger)
    r.Use(middleware.CORS)
    
    // 게임별 라우트
    r.Route("/api/v1/{game}", func(r chi.Router) {
        r.Use(middleware.GameValidator(gameRegistry))
        
        r.Get("/players/{playerID}/stats", gameHandler.GetPlayerStats)
        r.Get("/players/{playerID}/matches", gameHandler.GetPlayerMatches)
        r.Get("/players/{playerID}/insights", gameHandler.GetPlayerInsights)
    })
    
    return r
}
```

## 🎮 새로운 게임 추가 프로세스

### 1. 게임별 디렉터리 생성
```
internal/games/lol/
├── client/
│   ├── riot_client.go       # LoL API 클라이언트
│   └── models.go            # LoL API 응답 모델
├── service.go               # GameService 인터페이스 구현
├── transformer.go           # LoL → 공통 모델 변환
└── config.go               # LoL 특화 설정
```

### 2. 게임 서비스 구현
```go
// internal/games/lol/service.go
type LoLService struct {
    client *RiotClient
    cache  cache.Client
}

func (s *LoLService) GetPlayer(ctx context.Context, identifier string) (*domain.Player, error) {
    // LoL 특화 로직 구현
}

// 게임 등록 (main.go에서)
func main() {
    gameRegistry := NewGameRegistry()
    
    // 발로란트 서비스 등록
    valorantService := valorant.NewService(config.Valorant, db, cache)
    gameRegistry.Register(domain.GameTypeValorant, valorantService)
    
    // LoL 서비스 등록
    lolService := lol.NewService(config.LoL, db, cache)
    gameRegistry.Register(domain.GameTypeLoL, lolService)
}
```

### 3. 설정 구조 확장
```go
// internal/shared/config/config.go
type Config struct {
    Server   ServerConfig   `yaml:"server"`
    Database DatabaseConfig `yaml:"database"`
    Games    GamesConfig    `yaml:"games"`
    AI       AIConfig       `yaml:"ai"`
}

type GamesConfig struct {
    Valorant ValorantConfig `yaml:"valorant"`
    LoL      LoLConfig      `yaml:"lol"`
    CS2      CS2Config      `yaml:"cs2"`
}
```

## 🗄️ 데이터베이스 마이그레이션 전략

### 기존 발로란트 테이블을 범용으로 변경
```sql
-- 1. 새로운 범용 테이블 생성
CREATE TABLE players (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_type VARCHAR(20) NOT NULL,
    external_id VARCHAR(100) NOT NULL,
    display_name VARCHAR(100),
    raw_data JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(game_type, external_id)
);

-- 2. 기존 발로란트 데이터 마이그레이션
INSERT INTO players (game_type, external_id, display_name, raw_data)
SELECT 'valorant', riot_id, display_name, row_to_json(valorant_players.*)
FROM valorant_players;

-- 3. 게임별 인덱스 생성
CREATE INDEX idx_players_game_type ON players(game_type);
CREATE INDEX idx_players_external_id ON players(game_type, external_id);
```

## 📊 모니터링 및 메트릭

### 게임별 메트릭 수집
```go
// internal/shared/metrics/metrics.go
type Metrics struct {
    APICallsTotal     *prometheus.CounterVec
    ResponseTime      *prometheus.HistogramVec
    ErrorRate         *prometheus.CounterVec
    CacheHitRate      *prometheus.CounterVec
}

func (m *Metrics) RecordAPICall(game, endpoint string, duration time.Duration) {
    m.APICallsTotal.WithLabelValues(game, endpoint).Inc()
    m.ResponseTime.WithLabelValues(game, endpoint).Observe(duration.Seconds())
}
```

### 게임별 대시보드 구성
- 발로란트: API 호출 수, 응답 시간, 에러율
- LoL: API 호출 수, 응답 시간, 에러율
- 공통: 전체 시스템 메트릭, 캐시 히트율

## 🚀 배포 및 운영 전략

### Docker 멀티스테이지 빌드
```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go mod download
RUN go build -o gaming-platform cmd/server/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/gaming-platform .
COPY --from=builder /app/configs ./configs
CMD ["./gaming-platform"]
```

### 환경별 설정 관리
```yaml
# configs/production.yaml
server:
  port: 8080
  host: "0.0.0.0"

games:
  valorant:
    api_key: ${RIOT_API_KEY}
    rate_limit: 100
    cache_ttl: 300
  lol:
    api_key: ${RIOT_API_KEY}
    rate_limit: 100
    cache_ttl: 300

ai:
  openai:
    api_key: ${OPENAI_API_KEY}
  claude:
    api_key: ${CLAUDE_API_KEY}
```

## 🔄 점진적 마이그레이션 타임라인

### Week 1-2: 구조 준비
- [ ] 새로운 디렉터리 구조 생성
- [ ] 공통 도메인 모델 정의
- [ ] 게임 서비스 인터페이스 설계

### Week 3-4: 발로란트 서비스 리팩토링
- [ ] 기존 발로란트 코드를 새 구조로 이동
- [ ] GameService 인터페이스 구현
- [ ] 데이터베이스 스키마 변경

### Week 5-6: 공통 인프라 구축
- [ ] 게임 레지스트리 구현
- [ ] 공통 미들웨어 적용
- [ ] 모니터링 시스템 구축

### Week 7-8: 새 게임 추가 (LoL)
- [ ] LoL 서비스 구현
- [ ] API 엔드포인트 테스트
- [ ] 통합 테스트 수행

이 구조를 통해 새로운 게임을 추가할 때마다:
1. `internal/games/{game_name}/` 디렉터리 생성
2. GameService 인터페이스 구현
3. 게임 레지스트리에 등록
4. 설정 파일에 게임별 설정 추가

만 하면 됩니다. 기존 인프라와 API 구조는 그대로 재사용 가능합니다.
