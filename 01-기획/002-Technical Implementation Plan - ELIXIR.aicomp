H1:002_-_Technical_Impl_Plan|##_ðŸ—ï¸_Technical_Arch|###_Tech_Stack_Selection Backend:Elixir/Phoenix (OTP + LiveView) - highly concurrent,fault-tolerant Frontend:Phoenix LiveView + Alpine.js (reactive,server-rendered) Mobile:Flutter (cross-platform for iOS/Android) DB:PostgreSQL (with Phoenix Ecto) + real-time subscriptions AI API:Google AI API (Gemini models) External APIs:Riot Games API Deployment:Fly.io (backend) + Vercel (web assets)|### Proj Structure|``` gaming-report-card/ â”œâ”€â”€ mix.exs # Mix Proj file â”œâ”€â”€ config/ # Phoenix Config â”‚ â”œâ”€â”€ config.exs # Base config â”‚ â”œâ”€â”€ dev.exs # Dev config â”‚ â””â”€â”€ prod.exs # Production config â”œâ”€â”€ lib/ â”‚ â”œâ”€â”€ gaming_report_card/ # Business logic â”‚ â”‚ â”œâ”€â”€ accounts/ # User Mgmt â”‚ â”‚ â”œâ”€â”€ analytics/ # Game analytics â”‚ â”‚ â”œâ”€â”€ riot_api/ # Riot API client â”‚ â”‚ â””â”€â”€ ai_service/ # Google AI integration â”‚ â”œâ”€â”€ gaming_report_card_web/ # Phoenix web layer â”‚ â”‚ â”œâ”€â”€ controllers/ # HTTP controllers â”‚ â”‚ â”œâ”€â”€ live/ # LiveView modules â”‚ â”‚ â”œâ”€â”€ templates/ # EEx templates â”‚ â”‚ â””â”€â”€ router.ex # URL routing â”‚ â””â”€â”€ gaming_report_card.ex # App entry point â”œâ”€â”€ priv/ â”‚ â”œâ”€â”€ repo/migrations/ # DB migrations â”‚ â””â”€â”€ static/ # Static assets â”œâ”€â”€ assets/ # Frontend assets â”‚ â”œâ”€â”€ css/ â”‚ â”œâ”€â”€ js/ â”‚ â””â”€â”€ package.json â””â”€â”€ test/ # Test files ```|### Sys Arch ``` User Browser/Mobile App â†“ Phoenix LiveView (Fly.io) / Flutter App â†“ Elixir/Phoenix API (OTP Supervision) â†“ â”Œâ”€ Riot API â”€â” â”Œâ”€ Google AI API â”€â” â”‚ â”‚ â”‚ â”‚ â””â”€ Match Data â”˜ â””â”€ AI Insights â”˜ â†“ PostgreSQL DB + PubSub â†“ Phoenix Channels (optional for real-time features) ```|## ðŸ“ API Endpoints Design|### Core Endpoints ```elixir H1:Player_search_and_basic_info get "/api/players/:summoner_name/:tag_line",PlayerController,:show|# Daily report generation post "/api/reports/:summoner_name/:tag_line",ReportController,:create|# User Mgmt (premium features) post "/api/auth/register",AuthController,:register post "/api/auth/login",AuthController,:login get "/api/user/profile",UserController,:profile|# Health check get "/health",HealthController,:index|# LiveView routes live "/",HomeLive live "/player/:summoner_name/:tag_line",PlayerLive ```|### Data Flow 1. User Request:Phoenix LiveView/Flutter app sends summoner name + tag 2. Data Fetch:Backend queries Riot API for recent matches 3. Analysis:Process match data for trends using Elixir processes 4. AI Generation:Send analysis to Google AI API for insights 5. Response:Return formatted report card to frontend 6. Caching:Store â†’ PostgreSQL with TTL|## ðŸ”Œ Riot API Integration|### Required Endpoints ```elixir H1:Account_API_-_Get_player_info "GET /riot/account/v1/accounts/by-riot-id/#{game_name}/#{tag_line}"|# Match API - Get recent matches "GET /lol/match/v5/matches/by-puuid/#{puuid}/ids?count=5"|# Match details "GET /lol/match/v5/matches/#{match_id}" ```|### Rate Limiting Strategy Limit:120 requests per 2 minutes,Solution:GenServer-based rate limiter with ETS storage,Caching:Store match data in PostgreSQL for 24 hours,Optimization:Batch process multiple users using Task.async_stream|### Data Processing,```elixir defmodule GamingReportCard.Analytics.MatchAnalyzer do defstruct [:win_rate,:avg_kda,:trend_direction,:best_champion,:weakest_area ]|def analyze_player_performance(matches) do %__MODULE__{ win_rate:calculate_win_rate(matches),avg_kda:calculate_average_kda(matches),trend_direction:detect_trend(matches),best_champion:find_best_performing_champion(matches),weakest_area:identify_weaknesses(matches) } end end ```|## ðŸ¤– Google AI Integration|### API Usage Model:Gemini Pro (for quality) / Gemini Flash (for speed),Approach:Structured prompts with game data,Cost Mgmt:Cache identical analyses for 24 hours in PostgreSQL|### Prompt Template,```elixir defmodule GamingReportCard.AIService.PromptBuilder do def generate_insight_prompt(player_data) do """ You are a League of Legends coach analyzing a player's recent performance.|Player Data:- Recent Win Rate:#{Float.round(player_data.win_rate,1)}% - Average KDA:#{Float.round(player_data.avg_kda,2)} - Performance Trend:#{player_data.trend_direction} - Best Champion:#{player_data.best_champion} - Games Analyzed:5|Generate exactly 3 insights:1. Performance Trend Analysis (1-2 sentences) 2. Champion/Role Recommendation (1-2 sentences) 3. Key Improvement Focus (1-2 sentences)|Keep each insight actionable and encouraging. """ end end ```|### AI Response Processing ```elixir defmodule GamingReportCard.AIService.ResponseParser do defstruct [:performance_trend,:recommendation,:improvement_focus,:confidence ]|def parse_ai_response(response) do lines = response|> String.trim()|> String.split("\n")|> Enum.map(&String.trim/1)|> Enum.reject(&(&1 == ""))|case lines do [trend,recommendation,improvement|_] -> %__MODULE__{ performance_trend:trend,recommendation:recommendation,improvement_focus:improvement,confidence:"high" } _ -> # Fallback insights %__MODULE__{ performance_trend:"Keep playing consistently to track your improvement trends.",recommendation:"Focus on your best performing champions to climb ranks.",improvement_focus:"Work on map awareness and objective control for better results.",confidence:"medium" } end end end ```|## ðŸ’¾ PostgreSQL DB Schema|### Core Tables ```sql -- Users table CREATE TABLE users ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY,email VARCHAR(255) UNIQUE,password_hash VARCHAR(255),subscription_tier VARCHAR(20) DEFAULT 'free',inserted_at TIMESTAMP != NULL DEFAULT NOW(),updated_at TIMESTAMP != NULL DEFAULT NOW() );|-- Players table CREATE TABLE players ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY,summoner_name VARCHAR(100),tag_line VARCHAR(10),puuid VARCHAR(100) UNIQUE,region VARCHAR(10),inserted_at TIMESTAMP != NULL DEFAULT NOW(),updated_at TIMESTAMP != NULL DEFAULT NOW(),UNIQUE(summoner_name,tag_line) );|-- Daily reports table CREATE TABLE daily_reports ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY,player_id UUID REFERENCES players(id),report_date DATE,match_data JSONB,ai_insights JSONB,performance_score INTEGER,win_rate DECIMAL(5,2),avg_kda DECIMAL(5,2),inserted_at TIMESTAMP != NULL DEFAULT NOW(),updated_at TIMESTAMP != NULL DEFAULT NOW(),UNIQUE(player_id,report_date) );|-- API usage tracking CREATE TABLE api_usage ( id UUID DEFAULT gen_random_uuid() PRIMARY KEY,user_id UUID REFERENCES users(id),endpoint VARCHAR(100),request_count INTEGER DEFAULT 1,date DATE DEFAULT CURRENT_DATE,inserted_at TIMESTAMP != NULL DEFAULT NOW(),updated_at TIMESTAMP != NULL DEFAULT NOW(),UNIQUE(user_id,endpoint,date) ); ```|## ðŸ—ï¸ Backend Impl (Elixir/Phoenix)|### Main App Setup ```elixir H1:lib/gaming_report_card/App.ex defmodule GamingReportCard.App do use App|def start(_type,_args) do children = [ # Start the Ecto repository GamingReportCard.Repo,# Start the Telemetry supervisor GamingReportCardWeb.Telemetry,# Start the PubSub Sys {Phoenix.PubSub,name:GamingReportCard.PubSub},# Start Rate Limiter GenServer GamingReportCard.RiotAPI.RateLimiter,# Start the Endpoint (http/https) GamingReportCardWeb.Endpoint ]|opts = [strategy::one_for_one,name:GamingReportCard.Supervisor] Supervisor.start_link(children,opts) end|def config_change(changed,_new,removed) do GamingReportCardWeb.Endpoint.config_change(changed,removed):ok end end ```|### Router Impl ```elixir H1:lib/gaming_report_card_web/router.ex defmodule GamingReportCardWeb.Router do use GamingReportCardWeb,:router|pipeline:browser do plug:accepts,["html"] plug:fetch_session plug:fetch_live_flash plug:put_root_layout,{GamingReportCardWeb.LayoutView,:root} plug:protect_from_forgery plug:put_secure_browser_headers end|pipeline:api do plug:accepts,["json"] end|scope "/",GamingReportCardWeb do pipe_through:browser|live "/",HomeLive live "/player/:summoner_name/:tag_line",PlayerLive end|scope "/api",GamingReportCardWeb do pipe_through:api|get "/players/:summoner_name/:tag_line",PlayerController,:show post "/reports/:summoner_name/:tag_line",ReportController,:create post "/auth/register",AuthController,:register post "/auth/login",AuthController,:login get "/user/profile",UserController,:profile end|scope "/",GamingReportCardWeb do pipe_through:api get "/health",HealthController,:index end end ```|### Controllers Impl ```elixir H1:lib/gaming_report_card_web/controllers/report_controller.ex defmodule GamingReportCardWeb.ReportController do use GamingReportCardWeb,:controller alias GamingReportCard.Analytics alias GamingReportCard.RiotAPI|def create(conn,%{"summoner_name" => summoner_name,"tag_line" => tag_line}) do case Analytics.generate_daily_report(summoner_name,tag_line) do {:ok,report} -> conn|> put_status(:created)|> json(%{success:true,data:report}) {:error,reason} -> conn|> put_status(:unprocessable_entity)|> json(%{success:false,error:reason}) end end end|# lib/gaming_report_card_web/controllers/health_controller.ex defmodule GamingReportCardWeb.HealthController do use GamingReportCardWeb,:controller|def index(conn,_params) do json(conn,%{ success:true,data:%{ status:"healthy",timestamp:DateTime.utc_now(),service:"gaming-report-card" } }) end end ```|## ðŸŽ¨ Frontend Impl (Phoenix LiveView)|### Home Live View ```elixir H1:lib/gaming_report_card_web/live/home_live.ex defmodule GamingReportCardWeb.HomeLive do use GamingReportCardWeb,:live_view alias GamingReportCard.Analytics|def mount(_params,_session,socket) do {:ok,assign(socket,summoner_name:"",tag_line:"",loading:false)} end|def handle_event("search",%{"summoner_name" => summoner_name,"tag_line" => tag_line},socket) do send(self(),{:generate_report,summoner_name,tag_line}) {:noreply,assign(socket,loading:true)} end|def handle_info({:generate_report,summoner_name,tag_line},socket) do case Analytics.generate_daily_report(summoner_name,tag_line) do {:ok,report} -> {:noreply,socket|> assign(loading:false)|> push_redirect(to:"/player/#{summoner_name}/#{tag_line}")} {:error,reason} -> {:noreply,socket|> assign(loading:false)|> put_flash(:error,"Failed to generate report:#{reason}")} end end|def render(assigns) do ~H""" <div class="max-w-md mx-auto bg-white rounded-lg shadow-md p-6"> <h1 class="text-2xl font-bold text-center mb-6">Daily Gaming Report Card</h1> <form phx-submit="search" class="space-y-4"> <div> <label class="block text-sm font-medium text-gray-700 mb-2"> Summoner Name </label> <input type="text" name="summoner_name" value={@summoner_name} placeholder="Enter summoner name" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required> </div> <div> <label class="block text-sm font-medium text-gray-700 mb-2"> Tag Line </label> <input type="text" name="tag_line" value={@tag_line} placeholder="e.g.,NA1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required> </div> <button type="submit" disabled={@loading} class="w-full bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50"> <%= if @loading do %> <div class="inline-block animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div> Analyzing... <% else %> Generate Daily Report <% end %> </button> </form> </div> """ end end ```|## ðŸš€ Service Layer Impl|### Analytics Service ```elixir H1:lib/gaming_report_card/analytics.ex defmodule GamingReportCard.Analytics do alias GamingReportCard.{Repo,RiotAPI,AIService} alias GamingReportCard.Analytics.{Player,DailyReport,MatchAnalyzer}|def generate_daily_report(summoner_name,tag_line) do with {:ok,player} <- get_or_create_player(summoner_name,tag_line),{:ok,cached_report} <- get_cached_report(player),{:ok,report} <- cached_report|generate_new_report(player) do {:ok,report} end end|defp generate_new_report(player) do with {:ok,match_ids} <- RiotAPI.get_recent_matches(player.puuid,5),{:ok,matches} <- fetch_match_details(match_ids),analysis <- MatchAnalyzer.analyze_player_performance(matches),{:ok,insights} <- AIService.generate_insights(analysis) do report_data = %{ player:player,win_rate:analysis.win_rate,avg_kda:analysis.avg_kda,insights:insights,matches:matches }|# Cache the report save_daily_report(player,report_data) {:ok,report_data} end end|defp fetch_match_details(match_ids) do match_ids|> Task.async_stream(&RiotAPI.get_match_details/1,max_concurrency:3)|> Enum.reduce_while({:ok,[]},fn {:ok,{:ok,match}},{:ok,acc} -> {:cont,{:ok,[match|acc]}} {:ok,{:error,_}},{:ok,acc} -> {:cont,{:ok,acc}} # Skip failed matches {:error,reason},_ -> {:halt,{:error,reason}} end) end end ```|### Riot API Client ```elixir H1:lib/gaming_report_card/riot_api.ex defmodule GamingReportCard.RiotAPI do @base_url "https://americas.api.riotgames.com" alias GamingReportCard.RiotAPI.RateLimiter|def get_player_by_riot_id(game_name,tag_line) do path = "/riot/account/v1/accounts/by-riot-id/#{game_name}/#{tag_line}" with:ok <- RateLimiter.check_rate_limit(),{:ok,response} <- make_request(path) do {:ok,response} end end|def get_recent_matches(puuid,count \\ 5) do path = "/lol/match/v5/matches/by-puuid/#{puuid}/ids" params = %{count:count} with:ok <- RateLimiter.check_rate_limit(),{:ok,match_ids} <- make_request(path,params) do {:ok,match_ids} end end|def get_match_details(match_id) do path = "/lol/match/v5/matches/#{match_id}" with:ok <- RateLimiter.check_rate_limit(),{:ok,match} <- make_request(path) do {:ok,match} end end|defp make_request(path,params \\ %{}) do url = @base_url <> path headers = [ {"X-Riot-Token",App.get_env(:gaming_report_card,:riot_api_key)},{"Content-Type","App/json"} ]|case HTTPoison.get(url,headers,params:params) do {:ok,%HTTPoison.Response{status_code:200,body:body}} -> {:ok,Jason.decode!(body)} {:ok,%HTTPoison.Response{status_code:status}} -> {:error,"API request failed with status #{status}"} {:error,reason} -> {:error,reason} end end end ```|### Rate Limiter GenServer ```elixir H1:lib/gaming_report_card/riot_api/rate_limiter.ex defmodule GamingReportCard.RiotAPI.RateLimiter do use GenServer|@requests_per_window 120 @window_size_ms 120_000 # 2 minutes|def start_link(_) do GenServer.start_link(__MODULE__,[],name:__MODULE__) end|def check_rate_limit do GenServer.call(__MODULE__,:check_rate_limit) end|def init(_) do:ets.new(:rate_limiter,[:named_table,:public]) {:ok,%{}} end|def handle_call(:check_rate_limit,_from,state) do now = Sys.monotonic_time(:millisecond) window_start = now - @window_size_ms # Clean old entries:ets.select_delete(:rate_limiter,[{{:_,:"$1"},[{:<,:"$1",window_start}],[true]}]) # Count current requests current_requests =:ets.info(:rate_limiter,:size) if current_requests < @requests_per_window do:ets.insert(:rate_limiter,{make_ref(),now}) {:reply,:ok,state} else {:reply,{:error,:rate_limited},state} end end end ```|## ðŸ“¦ Deployment Config|### Dockerfile ```dockerfile H1:Build_stage FROM elixir:1.15-alpine AS builder|# Install build dependencies RUN apk add --no-cache build-base npm git python3|WORKDIR /app|# Install hex + rebar RUN mix local.hex --force && \ mix local.rebar --force|# Set build ENV ENV MIX_ENV=prod|# Install mix dependencies COPY mix.exs mix.lock ./ RUN mix deps.get --only prod RUN mix deps.compile|# Build assets COPY assets/package.json assets/package-lock.json ./assets/ RUN npm --prefix ./assets ci --progress=false --no-audit --loglevel=error|COPY priv priv COPY assets assets RUN npm run --prefix ./assets deploy RUN mix phx.digest|# Compile and build release COPY lib lib COPY config config RUN mix compile RUN mix release|# Release stage FROM alpine:3.18|RUN apk add --no-cache libstdc++ openssl ncurses-libs|WORKDIR /app|RUN addgroup -g 1001 -S app && \ adduser -S app -u 1001|COPY --from=builder --chown=app:app /app/_build/prod/rel/gaming_report_card ./|USER app|CMD ["./bin/gaming_report_card","start"] ```|### Fly.io Deployment ```toml H1:fly.toml app = "gaming-report-card" primary_region = "iad"|[build] dockerfile = "Dockerfile"|[env] PHX_HOST = "gaming-report-card.fly.dev" PORT = "8080"|[http_service] internal_port = 8080 force_https = true auto_stop_machines = true auto_start_machines = true min_machines_running = 1|InternalRef:[[http_service.checks]] interval = "30s" timeout = "10s" grace_period = "5s" method = "GET" path = "/health"|[postgres] app = "gaming-report-card-db" ```|### Environment Variables ```bash H1:.env_for_Dev PORT=4000 RIOT_API_KEY=RGAPI-your-key-here GOOGLE_AI_API_KEY=your-google-ai-key-here DATABASE_URL=ecto://postgres:postgres@localhost/gaming_report_card_dev SECRET_KEY_BASE=your-secret-key-base|# Production environment variables (Fly.io) RIOT_API_KEY= GOOGLE_AI_API_KEY= DATABASE_URL= SECRET_KEY_BASE= ```|## ðŸ”§ Real-time Features (Phoenix Channels)|### Optional Real-time Updates ```elixir H1:lib/gaming_report_card_web/channels/report_channel.ex defmodule GamingReportCardWeb.ReportChannel do use GamingReportCardWeb,:channel|def join("report:" <> _player_id,_payload,socket) do {:ok,socket} end|def handle_in("request_update",%{"player_id" => player_id},socket) do # Trigger background report generation Task.start(fn -> case GamingReportCard.Analytics.generate_daily_report_async(player_id) do {:ok,report} -> broadcast(socket,"report_updated",report) {:error,reason} -> broadcast(socket,"report_error",%{error:reason}) end end)|{:noreply,socket} end end ```|This updated technical Impl provides a robust foundation using Elixir/Phoenix with OTP supervision,LiveView for reactive interfaces,PostgreSQL for data persistence,and excellent fault tolerance through the Actor model.|--- Last Updated:July 17,2025 Status:Technical Impl Updated - Elixir/Phoenix/LiveView/Flutter Stack